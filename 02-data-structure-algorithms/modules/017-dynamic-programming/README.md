# Dynamic Programming   

 *  In recursion problems, sometimes we do repetitive computation. Ex. Fibonicci
 *  To reduce the time complexity , we can save the ans at the first time calculation which is nothing but called as ```Dynamic Programming``` .
 *  It is a ```Bottom - Up``` approach.
 *  Problems are solved **iteratively**.

---

 ###  Memoization: 
 *  Process of saving the previous results for future use is known as ```Memoization```.
 *  Helps in reducing the time complexity drastically.
 *  It is a ```Top - Down``` approach.
 *  Problems are solved **recursively**.

---

### Problems - Part 1:
[001 - Fibonicci Series](./code-part-1/001-Fibonicci.cpp)<br>
[002 - Count Steps To One](./code-part-1/002-Count-Setps-To-One.cpp)<br>
[003 - Stair Case](./code-part-1/003-StairCase.cpp)<br>
[004 - Minimum Count](./code-part-1/004-Minimum-Count.cpp)<br>
[005 - Number of Balanced Binary Trees](./code-part-1/005-Num-Balanced-BTs.cpp)<br>

---

### Problems - Part 2
[001 - Minimum Cost Path](./code-part-2/001-Min-Cost-Path.cpp)<br>
[002 - LCS (Longest Common Subsequence)](./code-part-2/002-lcs.cpp)<br>
[003 - Edit Distance](./code-part-2/003-Edit-Distance.cpp)<br>
[004 - Knapsack](./code-part-2/004-knapsack.cpp)<br>
[005 - Loot Houses](./code-part-2/005-Loot-Houses.cpp)<br>
[006 - Longest Increasing Subsequence](./code-part-2/006-longest-incresing-subsequence.cpp)<br>
[007 - All Possible Ways](./code-part-2/007-All-Possible-Ways.cpp)<br>
[008 - Ways To Make Coin Change](./code-part-2/008-Ways-To-Make-Coin-Change.cpp)<br>
[009 - Matrix Chain Multiplication](./code-part-2/009-Matrix-Chain-Multiplication.cpp)<br>
[010 - Coin Tower](./code-part-2/010-Coin-Tower.cpp)<br>
[011 - Maximum Square Matrix With All Zeros](./code-part-2/011-Max-Square-Matrix-With-Zeros.cpp)<br>
[012 - Shortest Subsequence](./code-part-2/012-Shortest-Subsequence.cpp)<br>

---